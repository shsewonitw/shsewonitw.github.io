---
layout: post
title: "[오늘의 공부] 파이썬 제너레이터(Generator)와 yield"
date: 2025-10-29 00:57:03 +0900
categories: [AI, Study]
---

---
title: 파이썬 제너레이터(Generator)와 yield 이해하기
layout: post
---

# 파이썬 제너레이터(Generator)와 yield 이해하기

안녕하세요! 오늘은 파이썬에서 매우 유용한 기능 중 하나인 제너레이터(generator)와 `yield` 키워드에 대해 알아보겠습니다. 이 개념들을 이해하면 메모리 효율성을 높이면서 대용량 데이터를 처리하는 코드를 작성할 때 매우 유용합니다.

## 1. 제너레이터(Generator)란 무엇인가?

제너레이터는 파이썬의 시퀀스(리스트, 딕셔너리, 등)를 생성할 때 사용하는 객체입니다. 하지만 일반적인 함수와는 다르게, 한 번에 모든 요소를 메모리에 로드하지 않습니다. 대신, 필요할 때마다 요소를 하나씩 '생성'합니다. 이는 특히 매우 큰 데이터를 다룰 때 메모리 사용을 절약할 수 있는 큰 장점을 가집니다.

### 1.1 제너레이터의 생성

제너레이터를 생성하는 방법은 크게 두 가지입니다:
1. 제너레이터 표현식 (generator expression), 이는 리스트 컴프리헨션과 유사합니다.
2. 제너레이터 함수 (generator function), 이는 일반 함수와 비슷하지만 `return` 대신 `yield` 키워드를 사용합니다.

#### 제너레이터 표현식 예:

```python
# 리스트 컴프리헨션
list_comprehension = [x * 2 for x in range(10)]

# 제너레이터 표현식
generator_expression = (x * 2 for x in range(10))
```

#### 제너레이터 함수 예:

```python
def count_down(num):
    while num > 0:
        yield num
        num -= 1
```

### 1.2 제너레이터의 사용

제너레이터는 `for` 루프나 다른 반복 가능한 문맥에서 사용할 수 있습니다.

```python
# 제너레이터 함수 사용 예
for number in count_down(10):
    print(number)
```

## 2. yield 키워드

`yield`는 제너레이터 함수 내에서 사용됩니다. 함수의 실행을 일시 중지하고 값을 반환하는 역할을 합니다. 또한 다음 호출 때, 마지막으로 실행이 중지된 지점부터 계속 실행됩니다.

### 2.1 yield의 동작 방식 이해

```python
def simple_gen():
    yield "Step 1"
    yield "Step 2"
    yield "Step 3"

gen = simple_gen()

print(next(gen))  # 출력: Step 1
print(next(gen))  # 출력: Step 2
print(next(gen))  # 출력: Step 3
```

### 2.2 제너레이터와 일반 함수의 차이점

일반 함수는 함수가 호출될 때마다 처음부터 끝까지 실행되고, 값이 필요할 때마다 모든 결과를 메모리에 유지해야 합니다. 그러나 제너레이터는 `yield`를 만날 때까지만 실행되고 필요한 값만 메모리에 유지하므로 매우 큰 시퀀스를 처리할 때 높은 메모리 효율을 보입니다.

## 3. 제너레이터의 장점

1. 메모리 효율성: 데이터 전체를 메모리에 로드하지 않고 필요할 때마다 데이터를 생성할 수 있습니다.
2. 코드 간결성: 반복적인 작업을 간단하게 표현할 수 있습니다.
3. 데이터 스트림 처리에 유리: 파일 처리나 네트워크 응답과 같이 대용량 데이터 스트림을 처리할 때 유리합니다.

제너레이터와 `yield` 키워드는 이해하기에 조금 복잡할 수 있지만, 한 번 익숙해지면 파이썬으로 효율적이고 강력한 프로그램을 작성하는 데 큰 도움이 됩니다. 이번 세션을 통해 이 개념들을 잘 이해하고 활용해보시기 바랍니다! Happy coding!

이상으로 파이썬의 제너레이터와 `yield` 사용에 대한 핵심 포인트를 다뤘습니다. 다음 코드나 프로젝트에서 이 테크닉을 사용하여 효율성을 높여보세요!
