---
layout: post
title: "[Daily morning study] Docker 컨테이너와 이미지의 차이점"
description: >
  #daily morning study
category: 
    - devlog
    - study
hide_last_modified: true
---

![Image](https://github.com/user-attachments/assets/1b38c764-1122-4c72-8acb-ac3a67750ee9)

---
---
title: "Docker — 컨테이너와 이미지의 차이점 (30분 학습 가이드)"
layout: default
date: 2025-10-29
---

# 개요

이 가이드는 'Docker 컨테이너와 이미지의 차이점'을 30분 안에 학습할 수 있도록 구성된 실전형 학습자료입니다. 핵심 개념 설명, 실습(명령어 포함), 요약 및 복습 문제로 이루어져 있습니다. 실제로 명령어를 입력해보며 학습할 것을 권장합니다.

학습 목표:
- Docker 이미지와 컨테이너의 본질적 차이점을 이해한다.
- 이미지와 컨테이너 관련 주요 명령어를 익히고 실습한다.
- 이미지/컨테이너의 라이프사이클과 저장/배포 방법을 이해한다.
- 실무에서의 모범 사례와 주의사항을 알게 된다.

권장 환경: Docker가 설치된 리눅스/macOS/Windows(WSL 권장) 머신

---

## 시간 배분 (총: 30분)

- 0–5분: 핵심 개념(이미지 vs 컨테이너) 정리
- 5–15분: 실습 1 — 이미지 빌드 및 컨테이너 실행
- 15–22분: 실습 2 — 컨테이너 수정, commit, save/load
- 22–27분: 이미지 레이어, 스토리지, 영구 저장소(볼륨) 이해
- 27–30분: 요약, 복습 문제 및 참고자료

---

## 1. 핵심 개념 정리 (5분)

- Docker 이미지(image)
  - 실행 가능한 애플리케이션의 "읽기 전용 템플릿"이다.
  - 파일 시스템과 메타데이터(명령어, 환경변수 등)를 포함한다.
  - 레이어(layer)로 구성되며, content-addressable(sha256) 방식으로 관리된다.
  - 불변(immutable)으로 다루는 것이 권장된다.
  - 예: ubuntu:20.04, node:18-alpine

- Docker 컨테이너(container)
  - 이미지를 기반으로 생성된 "실행 중인 인스턴스"이다.
  - 컨테이너는 이미지 위에 하나의 쓰기 가능한 레이어(writable layer)를 가진다.
  - 프로세스(또는 프로세스 집합), 네트워크, 파일시스템(이미지 + 쓰기 레이어) 등을 포함한다.
  - 기본적으로 상태(stateful)하거나 휘발성(ephemeral)할 수 있다(볼륨 사용 시 영속성 제공).
  - 하나의 이미지로 여러 컨테이너를 만들 수 있다.

간단한 비유:
- 이미지 = 소프트웨어의 "설계도" 또는 클래스(class)
- 컨테이너 = 그 설계도로 만든 "객체(instance)" — 프로그램이 실제로 동작하는 환경

---

## 2. 실습 1 — 이미지 빌드 및 컨테이너 실행 (10분)

목표: Dockerfile로 이미지 만들고, 컨테이너를 생성/실행해 차이를 직접 본다.

1) 작업 디렉토리 생성 및 간단한 Node 앱 준비
```bash
mkdir docker-study && cd docker-study
cat > app.js <<'EOF'
const http = require('http');
const port = process.env.PORT || 3000;
const server = http.createServer((req, res) => {
  res.end('Hello from container\\n');
});
server.listen(port, () => console.log('Listening on', port));
EOF
```

2) Dockerfile 작성
```bash
cat > Dockerfile <<'EOF'
FROM node:18-alpine
WORKDIR /app
COPY app.js .
CMD ["node", "app.js"]
EOF
```

3) 이미지 빌드
```bash
docker build -t study/hello:1.0 .
# 예상 출력: Successfully built <id> \n Successfully tagged study/hello:1.0
```

4) 이미지 확인
```bash
docker images study/hello
# REPOSITORY      TAG    IMAGE ID       ... SIZE
# study/hello     1.0    <sha256-id>    ... 
```

5) 컨테이너 실행
```bash
docker run -d --name hello1 -p 3000:3000 study/hello:1.0
# docker ps 로 확인
docker ps
# CONTAINER ID  IMAGE             COMMAND        ... PORTS
# <id>          study/hello:1.0   "node app.js"  ... 0.0.0.0:3000->3000/tcp
```

6) 컨테이너 접속(테스트)
```bash
curl http://localhost:3000
# Hello from container
```

실습 해설:
- `docker build`로 이미지를 생성. 이 이미지는 읽기 전용 템플릿.
- `docker run`은 이미지에서 컨테이너 인스턴스를 생성하고 실행.
- 동일 이미지를 여러 번 run하면 독립된 여러 컨테이너가 생성된다.

삭제:
```bash
docker rm -f hello1
docker rmi study/hello:1.0
```

---

## 3. 실습 2 — 컨테이너 수정 후 commit, save/load (7분)

목표: 컨테이너의 쓰기 레이어를 실험하고, 변경 사항을 이미지로 만들기

1) 컨테이너 실행 후 내부 수정
```bash
docker run -it --name temp1 study/hello:1.0 sh
# 컨테이너 쉘에서
echo "console.log('modified');" >> app.js
exit
```

2) 변경 사항은 컨테이너의 쓰기 레이어에만 존재
```bash
docker exec temp1 cat app.js | tail -n 1
# console.log('modified');
```

3) 컨테이너를 이미지로 커밋
```bash
docker commit temp1 study/hello:modified
# 새 이미지가 생성됨
docker images | grep study/hello
```

4) commit한 이미지로 새 컨테이너 실행
```bash
docker run --rm study/hello:modified node app.js
# app.js가 수정된 상태로 동작
```

5) 이미지 저장/불러오기 (tar로 이동/공유)
```bash
docker save study/hello:modified -o hello_modified.tar
# 다른 머신에서
docker load -i hello_modified.tar
```

실습 해설:
- 컨테이너 내부에서 파일을 수정하면 이미지가 바뀌지 않고, 해당 컨테이너의 쓰기 레이어에만 반영된다.
- `docker commit`은 그 쓰기 레이어를 새로운 이미지로 만들며, 이는 일회성이거나 임시적(권장 안 됨)이다.
- 배포/이전은 `docker push`/`docker save`/`docker load`로 가능.

정리 명령:
```bash
docker rm -f temp1
docker rmi study/hello:modified
```

---

## 4. 이미지 레이어와 저장소 구조(3분)

- 이미지 레이어
  - Dockerfile의 각 명령(RUN, COPY 등)은 새로운 레이어를 만든다.
  - 레이어는 읽기 전용이며 이전 레이어 위에 쌓인다 (Union FS — overlay2 등).
  - 레이어 재사용: 동일한 레이어는 캐시되어 빌드/다운로드 효율이 높아진다.

- 컨테이너의 쓰기 레이어
  - 컨테이너가 실행될 때 이미지 위에 하나의 쓰기 레이어가 추가된다.
  - 모든 변경(파일 생성/삭제/수정)은 쓰기 레이어에 기록된다.
  - 컨테이너 삭제 시 쓰기 레이어도 삭제되어 변경사항이 사라진다(영속성 없음).

- 이미지 식별자
  - 태그(tag): 사람이 읽기 쉬운 이름(예: ubuntu:20.04)
  - 이미지 ID: 고유 sha256 ID
  - 다수의 태그가 같은 이미지 ID를 가리킬 수 있음

---

## 5. 영속성: 볼륨과 바인드 마운트(2분)

- 컨테이너의 파일 변경을 보존하려면 볼륨(volume) 또는 호스트 바인드 마운트를 사용한다.
- 볼륨은 컨테이너와 독립적으로 존재하며 컨테이너 삭제 후에도 보존된다.
- 예:
```bash
docker run -d --name data-demo -v mydata:/data busybox sh -c "echo hello > /data/msg && sleep 3600"
docker run --rm -v mydata:/data busybox cat /data/msg
# hello
```

설명: 이미지는 불변, 컨테이너의 일시적 쓰기 레이어는 휘발성, 중요한 데이터는 볼륨에 보관.

---

## 6. 모범 사례와 주의사항 (2분)

- 이미지는 가능한 작게(production: multi-stage, alpine 사용) 유지.
- 컨테이너 내에서 상태(데이터)를 보관하지 말고 볼륨/외부 DB 사용.
- 이미지 변경은 Dockerfile로 관리하자 — `docker commit`은 재현성이 떨어짐.
- 이미지 레지스트리(예: Docker Hub, GitHub Container Registry)에 신뢰할 수 있는 태그와 시그니처 사용.
- 보안: 이미지 스캔(취약점 스캐너) 및 최소 권한으로 실행(비루트 사용자) 권장.

---

## 7. 명령어 치트시트 (빠른 참조)

- 이미지 관련
  - docker images
  - docker build -t name:tag .
  - docker rmi <image>
  - docker history <image>
  - docker save -o file.tar <image>
  - docker load -i file.tar

- 컨테이너 관련
  - docker run [옵션] <image>
  - docker ps / docker ps -a
  - docker exec -it <container> sh/bash
  - docker inspect <container|image>
  - docker commit <container> <new-image>
  - docker rm <container> / docker rm -f <container>
  - docker logs <container>

- 볼륨
  - docker volume create mydata
  - docker run -v mydata:/data ...
  - docker volume ls / docker volume rm

---

## 8. 복습 문제 (마무리: 3분)

1. 이미지와 컨테이너의 가장 큰 차이점은 무엇인가?
2. 컨테이너에서 파일을 수정한 뒤 해당 변경을 이미지로 만들려면 어떤 명령을 사용하는가? 이것을 사용하는 이유/단점은?
3. 컨테이너의 데이터를 컨테이너 삭제 후에도 보존하려면 어떻게 해야 하나?
4. 이미지 레이어가 재사용되는 이유는 무엇인가? (효율 측면)

정답(요약)
1. 이미지 = 읽기 전용 템플릿(불변), 컨테이너 = 이미지 기반의 실행 인스턴스(쓰기 레이어 포함).  
2. docker commit. 장점: 빠르게 이미지화 가능. 단점: 재현성/버전관리 불투명, 권장되지 않음 — Dockerfile 이용 권장.  
3. 볼륨(volume) 또는 호스트 바인드 마운트 사용.  
4. 레이어는 내용 기반 식별자(캐시/중복 제거)로 저장되어 동일한 변경을 재사용할 수 있어 빌드·다운로드 효율이 높다.

---

## 참고자료

- Docker 공식 문서 — 컨테이너와 이미지: https://docs.docker.com/get-started/
- Dockerfile best practices: https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
- Docker storage drivers (overlay2 등) 소개: https://docs.docker.com/storage/storagedriver/

---

필요하면 실습용 Dockerfile/스크립트를 더 제공하거나, CI로 이미지 빌드-태그-푸시하는 흐름(CI 파이프라인 예시)을 추가로 작성해 드리겠습니다.
